Let's talk about the word microcontroller. Or more specifically, let's talk about how the word microcontroller fits into the hierarchy of a computer system.  I've been to so many hackathons where individuals say "let's just use Arduino" for projects anytime there's hardware involved. In fact, Arduino has become ubiquitous with hardware projects.

One Size Fits Small

The phrase "one size fits all" conjures images of baseball caps and graduation gowns. For the software engineer, one of the biggest selling points of Arduino was its "one size fits all" approach to hardware programming. It's not uncommon to go to a hackathon and hear the terms "hardware project" and "Arduino" used interchangeably. In recent years, other platforms like the Raspberry Pi have emerged, but the word Arduino is synonymous with hardware programming.

The world of hardware is so much bigger than Arduino.  Yes, Arduino is comfortable. Programming in Arduino is wonderfully convenient and to a software-savvy individual, the learning curve is negligible.

The reality is that the world of hardware is so much bigger. An Arduino is a simplification on a simplification when it comes to hardware. This article is intended for those with a software background.

I've heard way too many people confuse microcontroller, microprocessor, and Arduino. For this hardware-based software programming, it's important to understand the hierarchy.  An Arduino is really like an onion and you can peel the layers to reach lower and lower levels of abstraction. Let's work from the smallest category out.

<picture of microprocessor>

A microprocessor is the brain of your computer and it is, in essence, a fancy calculator (called an Arithmatic Logic Unit, or ALU). The program you write essentially feeds into this ALU line by line.

While the processor can do all the standard calculator operations like addition and subtraction, it can perform other functions such as branching which is conditionally changing which line of the program it is executing.  The processor also only has minimal internal memory because it is built for fast operation, so part of its job is to write things to external memory which is not included as part of the processor.

There is no one architecture for the inside of a processor.  The layout of the ALU as well as the required layout of the instructions fed through to the processor vary based off of the processor's instruction set architecture, or ISA. The most common architectures include x86 (old Intel ISA), x86-64 (newer Intel ISA), ARM, ARM32, AVR, Z80, and MIPS.  To learn more about instruction set architecture and the internals of a computer, you can take a look at my article here covering that topic.

It is uncommon to find discrete processor chips these days - the internals of a microprocessor are typically contained within a microcontroller, which is our next topic.  Standalone microprocessor are essentially obsolete in this day and age - to find a good example of one, we have to go back to 1974.  Here is a picture of the Intel 8085 microprocessor:

<picture of microprocessor>

Again - it is uncommon to see a discrete integrated circuit that is <b>just</b> a microprocessor in this day and age. More commonly, chips that look like the above chip will be a complete integrated microcontroller, not just a microprocessor.

We can usually tell the difference between a microprocessor and a microcontroller chip by checking if the chip has multiple pins used as part of an address bus.  In a microprocessor, the buses (usually 8 lines labeled A0-A7) are available on distinct pins.  Microcontrollers keep their buses on the inside and don't reveal them to the user.  When we look at the pinout for the 8085, we see that the buses are externally available.

<pinout>  

If we look at the pinout for this specific chip, we'll see that there are 8 pins labeled "AD" and 8 pins labeled "A#".  These AD pins correspond to the address/data bus (can be used as either) and the A8-A15 are additional pins that make the address bus 16 bits instead of only 8 bits.  The rest of the pins include power/ground and several control signals that allow the chip to communicate with peripherals.

Microprocessors are the closest we will get to the core of the logical ratsnest that is computer processing.  They are the lowest level - where thinking and logic truly meet hardware.  They are beautiful and mysterious like the human brain is beautiful when viewed as a isolated system.

But microprocessors, like the human brain, weren't designed to work in isolation. Microprocessors often don't have memory to store programs. They don't have infrastructure in place to add programs. Most importantly perhaps, they don't have support for input/output because they lack memory.  They are like a calculator with no screen, no buttons, and no hands to operate it.  Technically, it can be called a calculator because it has the core of a calculator, but it's barely usable without all of the support that makes it a calculator as we know it.

If we add all of these necessary peripherals like memory and I/O support onto the same chip as the microprocessor to make it more usable, it becomes a microcontroller.

<h2> Microcontrollers </h2>



<!--    MOVE TO NEW ARTICLE     --->

Every instruction set architecture has different assembly code and corresponding machine code.  The language "assembly" is really a catch-all for every one of these lowest level.  For example, let's consider the case of copying the value in one register (r0) to another register (r1).  Registers are essentially a type of memory within the processor used for calculations.

In x86 assembly, the line that accomplishes this would be
mov r1, r0

In AVR assembly, it's identical
mov r1, r0

Where these two commands diverge is in their machine code.  A single line in assembly that is valid in two types of assembly can be compiled into two different languages' machine code

In x86 machine code, the command compiles to
A0 01 00 (binary 1010 0000 0000 0000 0000 0001)

In AVR machine code, the command compiles to
2C 10 (binary 0010 1100 0001 0000)

These hexadecimal machine code values are, in reality, sequences of 1s and 0s (high and low voltage) that are fed to the processor.  The processor, considered as a complex calculator, looks at this sequence of 1s and 0s and uses it to flip a series of switches that effectively complete the calculation.  Processor architecture is beautiful and I highly recommend reading into it to gain a better understanding of the true magic that makes computers work.

<!--   END    -->




