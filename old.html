
<html><head>
<title>Cameron Akker</title>
<meta name="viewport" content="1000, initial-scale=1.0">

<style type="text/css">
 .pos_top {background-color:#002244; position:absolute; left:0px; right:5px; top:5px; padding:2px; }
 .pos_menushadow {background-color:#A5ACAF; position:absolute; left:12px; top:57px; width:170px; padding:3px; border: 1px solid  #ffffff;}
 .pos_menu {background-color:#dddddd; position:absolute; left: 8px; top:50px; width:170px; padding:3px; border: 1px outset #000000;}
 .pos_content {position:absolute; left:220px; top:110px; margin:0px; }

 div, table {font-family: Verdana,Tahoma,Arial; font-size:12;}
 pre {font-family: 'Lucida Sans Typewriter Regular', 'Lucida Console'; font-size:12;}
 h1 {font-size: 240%}
 h2 {font-size: 210%}
 h3 {font-size: 190%}
 h4 {font-size: 160%}
 h5 {font-size: 130%}
 h6 {font-size: 110%}
 a {text-decoration:none; color:black; font-weight:bold;}
 a:hover {text-decoration:underline;}
 .link {color:#000080;}
 .link:hover {text-decoration:underline; color:blue;}
 pre {background: #d0d0f0; padding: 5px; margin: 5px;}
</style>
</head>

<!-- Top Navigation Bar with Name and Contact Information -->
<body marginwidth="0" marginheight="0" rightmargin="0" topmargin="0" leftmargin="0">
  <div class="pos_top">
    <table width="100%">
      <tr> <!-- First Row -->
        <td width=200></td>  <!-- Leaves Space on the Left Side of the Images -->
        <td><br>  <h1 style="color:white;"> Cameron Akker</h1>  </td></tr>
    </table>
  </div>

<!-- Side Menu Bar with Project Links -->
<div class="pos_menu">
<font color="#9090c0"><b>
<br>
<br>

Home<br>
<a class='link' href='index.html'>Welcome</a><br>
<a class='link' href='SiteInformation.html'>Information</a><br>

<hr>
<br>FPGA projects - Basic<br>
<a class='link' href='MusicBox.html'>Music box</a><br>
<a class='link' href='Opto.html'>LED displays</a><br>
<a class='link' href='PongGame.html'>Pong game</a><br>
<a class='link' href='RCServos.html'>R/C servos</a><br>
<a class='link' href='TextLCDmodule.html'>Text LCD module</a><br>
<a class='link' href='QuadratureDecoder.html'>Quadrature decoder</a><br>
<a class='link' href='PWM_DAC.html'>PWM and one-bit DAC</a><br>
<a class='link' href='Debouncer.html'>Debouncer</a><br>
<a class='link' href='CrossClockDomain.html'>Crossing clock domains</a><br>
<a class='link' href='Counters.html'>The art of counting</a><br>
<a class='link' href='ExternalContributions'>External contributions</a><br>

<br>Interfaces<br>
<a class='link' href='SerialInterface.html'>RS-232</a><br>
<a class='link' href='JTAG.html'>JTAG</a><br>
<a class='link' href='I2C.html'>I2C</a><br>
<a class='link' href='EPP.html'>EPP</a><br>
<a class='link' href='SPI.html'>SPI</a><br>
<a class='link' href='SD.html'>SD card</a><br>
<a class='link' href='PCI.html'>PCI</a><br>
<a class='link' href='PCI-Express.html'>PCI Express</a><br>
<a class='link' href='10BASE-T.html'>Ethernet</a><br>
<a class='link' href='HDMI.html'>HDMI</a><br>
<a class='link' href='SDRAM.html'>SDRAM</a><br>

<br>Advanced<br>
<a class='link' href='digitalscope.html'>Digital oscilloscope</a><br>
<a class='link' href='GraphicLCDpanel.html'>Graphic LCD panel</a><br>
<a class='link' href='DDS.html'>Direct Digital Synthesis</a><br>
<a class='link' href='CNC.html'>CNC steppers</a><br>
<a class='link' href='spoc.html'>Spoc CPU core</a><br>

<br>Hands-on<br>
<a class='link' href='Hands-on_Flashy.html'>A simple oscilloscope</a><br>

<hr>
<br>FPGA introduction<br>
<a class='link' href='FPGAinfo1.html'>What are FPGAs?</a><br>
<a class='link' href='FPGAinfo2.html'>How FPGAs work</a><br>
<a class='link' href='FPGAinfo3.html'>Internal RAM</a><br>
<a class='link' href='FPGAinfo4.html'>FPGA pins</a><br>
<a class='link' href='FPGAinfo5.html'>Clocks and global lines</a><br>
<a class='link' href='FPGAinfo6.html'>Download cables</a><br>
<a class='link' href='FPGAinfo7.html'>Configuration</a><br>
<a class='link' href='FPGAinfo8.html'>Learn more</a><br>

<br>FPGA software<br>
<a class='link' href='FPGAsoftware1.html'>Design software</a><br>
<a class='link' href='FPGAsoftware2.html'>Design-entry</a><br>
<a class='link' href='FPGAsoftware3.html'>Simulation</a><br>
<a class='link' href='FPGAsoftware4.html'>Pin assignment</a><br>
<a class='link' href='FPGAsoftware5.html'>Synthesis and P&amp;R</a><br>

<br>FPGA electronic<br>
<a class='link' href='SMD.html'>SMD technology</a><br>
<a class='link' href='oscillators.html'>Crystals and oscillators</a><br>

<br>HDL info<br>
<a class='link' href='HDL tutorials.html'>HDL tutorials</a><br>
<a class='link' href='VerilogTips.html'>Verilog tips</a><br>
<a class='link' href='VHDLTips.html'>VHDL tips</a><br>

<br>Quick-start guides<br>
<a class='link' href='ISEQuickStart.html'>ISE</a><br>
<a class='link' href='QuartusQuickStart.html'>Quartus-II</a><br>

<br>Site<br>
<!--<a class='link' href='news.html'>News</a><br>-->
<a class='link' href='Links.html'>Links</a><br>
<a class='link' href='HDL tutorials.html'>HDL tutorials</a><br>

</b></font>
<br><br>
</div>

<div class="pos_content">
<h4>Text LCD module</h4><p>Text LCD modules are cheap and easy to interface using a microcontroller or FPGA.</p>

<p>Here's a 1 line x 16 characters module:</p>
<p><img src="images/LCD_FPGAs_are_fun.jpg"></p>

<p>To control an LCD module, you need 11 IO pins to drive an 8-bits data bus and 3 control signals.

The 3 control signals are:</p>
<ul class="NewList">
<li>E: enable, or "LCD-select". Active high.</li>
<li>R/W: read/write. 0 to write, 1 to read.</li>
<li>RS: register select, 0 for command bytes, 1 for data bytes.</li>
</ul>

<p>Most of the LCD modules are based on the HD44780 chip or compatible. One good information page is available <a href="http://www.doc.ic.ac.uk/~ih/doc/lcd/">here</a>.</p>

<h4>7 bits design</h4>
<p>Let's drive the LCD module from an FPGA board.<br>
Here's the block diagram of our design:</p>
<img src="images/LCDmodule.gif">

<p><a href="http://www.knjn.com/FPGA-RS232.html">Pluto</a> receives data from the PC serial port, de-serializes it, and send it to the LCD module.
The de-serializer is the same module from the <a href="SerialInterface.html">serial interface</a> project, so it is just instantiated here.</p>

<table cellPadding=10><tr><td bgcolor="#d0d0f0">
<b>module</b> LCDmodule(clk, RxD, LCD_RS, LCD_RW, LCD_E, LCD_DataBus);<br>
<b>input</b> clk, RxD;<br>
<b>output</b> LCD_RS, LCD_RW, LCD_E;<br>
<b>output</b> [7:0] LCD_DataBus;<br><br>

<b>wire</b> RxD_data_ready;<br>
<b>wire</b> [7:0] RxD_data;<br>
async_receiver deserialer(.clk(clk), .RxD(RxD), .RxD_data_ready(RxD_data_ready), .RxD_data(RxD_data));
</td></tr></table>

<p>Every time a byte becomes available from the serial port, then "RxD_data_ready" is active for one clock period.</p>

<p>The PC sends us data through the serial port in 8-bits mode.
Ideally, we would need to receive 9 bits from the PC, so that we can drive the 8-bits data bus and the "RS" line of the LCD module.
For now, let's use the MSB (bit 7) of the data received to drive "RS", and send only 7 bits to the data bus.</p>

<table cellPadding=10><tr><td bgcolor="#d0d0f0">
<b>assign</b> LCD_RS = RxD_data[7];<br>
<b>assign</b> LCD_DataBus = {1'b0, RxD_data[6:0]}; &nbsp; // sends only 7 bits to the module, padded with a '0' in front to make 8 bits<br><br>
<b>assign</b> LCD_RW = 0;<br>
</td></tr></table>

<p>We never read from the LCD module, so the R/W line is tied to ground.</p>

<p>The last complication is that the "E" signal needs to be active for a long time, 220ns.
That's long from the FPGA point of view, since I use a 25MHz clock (40ns period).
So "E" needs to be driven for at least 5.5 clocks.
Here we drive it for 7 clocks, using a counter to count the clocks.</p>

<table cellPadding=10><tr><td bgcolor="#d0d0f0">
<b>reg</b> [2:0] count;<br>
<b>always</b> @(<b>posedge</b> clk) <b>if</b>(RxD_data_ready | (count!=0)) count <= count + 1;
</td></tr></table>

<p>The "E" signal is created using a register, so that it is guaranteed to be glitch-free.</p>

<table cellPadding=10><tr><td bgcolor="#d0d0f0">
<b>reg</b> LCD_E;<br>
<b>always</b> @(<b>posedge</b> clk) LCD_E <= (count!=0);
</td></tr></table>

<p>The waveform looks like that:</p>

<p><img src="images/LCDmodule_waveform.gif"></p>

<p>The HDL design is <a href="files/LCDmodule.zip">here</a>.</p>

<h4>The software</h4>
<p>We initialize the LCD and send some data to be displayed.</p>

<p><img src="images/LCD_hello.jpg"></p>

<p>Here's the C code to initialize the LCD module and display 'hello'.</p>

<table cellPadding=10><tr><td bgcolor="#d0f0d0">
void main()<br>
{<br>
&nbsp; OpenComm();<br><br>

&nbsp; // initialize the LCD module<br>
&nbsp; WriteCommByte(0x38); &nbsp; // "Function Set" in 8 bits mode<br>
&nbsp; WriteCommByte(0x0F); &nbsp; // "Display ON" with cursors ON<br>
&nbsp; WriteCommByte(0x01); &nbsp; // "Clear Display", can take up to 1.64ms, so the delay<br>
&nbsp; Sleep(2);<br><br>

&nbsp; // display "hello"<br>
&nbsp; WriteCommByte('h' + 0x80);<br>
&nbsp; WriteCommByte('e' + 0x80);<br>
&nbsp; WriteCommByte('l' + 0x80);<br>
&nbsp; WriteCommByte('l' + 0x80);<br>
&nbsp; WriteCommByte('o' + 0x80);<br><br>

&nbsp; CloseComm();<br>
}
</td></tr></table>

<p>The complete code is <a href="files/LCDmodule_com.zip">here</a>.</p>

<p>To get more info about the HD44780 instruction set, <a href="http://www.doc.ic.ac.uk/~ih/doc/lcd/instruct.html">check here</a>.</p>

<h4>8 bits design</h4>
<p>The major drawback is the earlier design is that we send only 7 bits to the LCD data bus.
That is a problem because the <a href="http://www.doc.ic.ac.uk/~ih/doc/lcd/instructions/sdd.html">set DD RAM Address</a> command of the LCD module cannot be used anymore.</p>

<p>One easy way around that is to use an escape character.
We chose character 0x00.</p>

<p>The new protocol is as follow:</p>
<ul class="NewList">
<li>To send a command byte, prefix it with 0x00.</li>
<li>To send a data byte, just send it, no prefix required.</li>
</ul>

<p>The new C code is:</p>

<table cellPadding=10><tr><td bgcolor="#d0f0d0">
void main()<br>
{<br>
&nbsp; OpenComm();<br><br>

&nbsp; // initialize the LCD module<br>
&nbsp; WriteCommByte(0x00); &nbsp;WriteCommByte(0x38); &nbsp; // "Function Set" in 8 bits mode<br>
&nbsp; WriteCommByte(0x00); &nbsp;WriteCommByte(0x0F); &nbsp; // "Display ON" with cursors ON<br>
&nbsp; WriteCommByte(0x00); &nbsp;WriteCommByte(0x01); &nbsp; // "Clear Display", can take up to 1.64ms, so the delay<br>
&nbsp; Sleep(2);<br><br>

&nbsp; WriteCommByte('h');<br>
&nbsp; WriteCommByte('e');<br>
&nbsp; WriteCommByte('l');<br>
&nbsp; WriteCommByte('l');<br>
&nbsp; WriteCommByte('o');<br><br>

&nbsp; WriteCommByte(0x00); &nbsp;WriteCommByte(0xC0); &nbsp; // go on second half of LCD<br>
&nbsp; WriteCommByte('e');<br>
&nbsp; WriteCommByte('v');<br>
&nbsp; WriteCommByte('e');<br>
&nbsp; WriteCommByte('r');<br>
&nbsp; WriteCommByte('y');<br>
&nbsp; WriteCommByte('o');<br>
&nbsp; WriteCommByte('n');<br>
&nbsp; WriteCommByte('e');<br><br>

&nbsp; CloseComm();<br>
}
</td></tr></table>

<p>The new HDL code looks like:</p>

<table cellPadding=10><tr><td bgcolor="#d0d0f0">
<b>module</b> LCDmodule(clk, RxD, LCD_RS, LCD_RW, LCD_E, LCD_DataBus);<br>
<b>input</b> clk, RxD;<br>
<b>output</b> LCD_RS, LCD_RW, LCD_E;<br>
<b>output</b> [7:0] LCD_DataBus;<br><br>

<b>wire</b> RxD_data_ready;<br>
<b>wire</b> [7:0] RxD_data;<br>
async_receiver deserialer(.clk(clk), .RxD(RxD), .RxD_data_ready(RxD_data_ready), .RxD_data(RxD_data));<br><br>

<b>assign</b> LCD_RW = 0;<br>
<b>assign</b> LCD_DataBus = RxD_data;<br><br>

<b>wire</b> Received_Escape = RxD_data_ready & (RxD_data==0);<br>
<b>wire</b> Received_Data = RxD_data_ready & (RxD_data!=0);<br><br>

<b>reg</b> [2:0] count;<br>
<b>always</b> @(<b>posedge</b> clk) <b>if</b>(Received_Data | (count!=0)) count <= count + 1;<br><br>

// activate LCD_E for 6 clocks, so at 25MHz, that's 6x40ns=240ns<br>
<b>reg</b> LCD_E;<br>
<b>always</b> @(<b>posedge</b> clk)<br>
<b>if</b>(LCD_E==0)<br>
&nbsp; LCD_E <= Received_Data;<br>
<b>else</b><br>
&nbsp; LCD_E <= (count!=6);<br><br>

<b>reg</b> LCD_instruction;<br>
<b>always</b> @(<b>posedge</b> clk)<br>
<b>if</b>(LCD_instruction==0)<br>
&nbsp; LCD_instruction <= Received_Escape;<br>
<b>else</b><br>
&nbsp; LCD_instruction <= (count!=7);<br><br>

<b>assign</b> LCD_RS = ~LCD_instruction;<br><br>

<b>endmodule</b>
</td></tr></table>

<p>The HD44780 specification shows that "RS" needs to be valid for 10ns after "E" goes low.
So you'll note that here "E" is driven for 6 clocks only, and the "LCD_instruction" flag is reset only after clock 7, to give 25ns room.</p>

<p><img src="images/LCDmodule_waveform2.gif"></p>

<p>That's all folks! Your turn to experiment.</p>

<h4>Links</h4>
<ul>
<li>More information on the <a href="http://www.hantronix.com/3_3.html">About LCD's</a> and <a href="http://www.hantronix.com/3_1.html">Application notes</a> from <a href="http://www.hantronix.com/">Hantronix</a> web site.</li>
</ul>
<br>
<br><br><br><br><hr>This page was last updated on December 02 2009.<br><br></div>

</body>
</html>
